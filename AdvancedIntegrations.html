<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Advanced Integrations</title>
    <meta name="keywords" content="Frankly Chat Service Platform" />
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
    <link type="text/css" rel="stylesheet" href="css/main.css">
    <link type="text/css" rel="stylesheet" href="css/bootstrap.css">	
    <link rel="stylesheet" type="text/css">
	<link rel="icon" 
	      type="image/png" 
	      href="frankly_favicon_32x32_no_bg.png">
	<script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js?skin=sunburst"></script>
	<script src="http://code.jquery.com/jquery-1.11.3.min.js"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
	<script src="js/load_frankly_menus.js"></script>
	
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-65350925-1', 'auto');
	  ga('send', 'pageview');

	</script>

	<script> 
	var frankly_menu = [
	'<ul>',
		'<li><a href="http://franklyinc.github.io">Getting Started</a></li>',
		'<li><a href="InstallSDK.html">Installing the SDK</a></li>',
		'<li><a href="InitializeSDK.html">Initializing the SDK</a>',
		'<li><a href="Auth.html">Authenticating</a>',
		'<li><a href="BasicIntegration.html">Basic Integration</a>',
		'<li><a href="AdvancedIntegrations.html">Advanced Integrations</a>',
			'<ul>',
				'<li><a href="#Open_Room">Directly Opening a Room</a></li>',
				'<li><a href="#Server_APIs">Server API Access</a></li>',
				'<li><a href="#Installing_ServerSDKs">Server SDKs</a></li>',
				'<li><a href="#Indepth_Usage">Indepth Usage</a></li>',
       			    '<ul>',
				        '<li><a href="#Authentication">Authentication</a></li>',
				        '<li><a href="#Rooms">Rooms</a></li>',
				        '<li><a href="#Messages">Messages</a></li>',
				        '<li><a href="#Announcements">Announcements</a></li>',
				        '<li><a href="#Users">Users</a></li>',
				        '<li><a href="#Files">Files</a></li>',
				        '<li><a href="#Moderation">Moderation</a></li>',
			        '</ul>',
				'<li><a href="#JS_SDK_Meteor">JavaScript SDK + Meteor</a></li>',
			'</ul>',
		'</li>',
		'<li><a href="APIReference.html">API Reference</a>',
		'<li><a href="downloads.html">Downloads</a>',
		'<li><a href="Support.html">Contact & Support</a>',
	'</ul>'
	];
	
	
	jQuery(document).ready(function($){
  		set_menu_array(frankly_menu);
  	});
	</script>
	
	<script>
		(function() {
			var cx = '007928927613488122909:hbugzpc0lua';
			var gcse = document.createElement('script');
			gcse.type = 'text/javascript';
			gcse.async = true;
			gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
				'//cse.google.com/cse.js?cx=' + cx;
			var s = document.getElementsByTagName('script')[0];
			s.parentNode.insertBefore(gcse, s);
		})();
	</script>
	
</head>

<nav class="navbar navbar-inverse" role="navigation" style="z-index:100">
   <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" 
         data-target="#frankly-navbar-collapse">
         <span class="sr-only">Toggle navigation</span>
         <span class="icon-bar"></span>
         <span class="icon-bar"></span>
         <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="http://franklyinc.github.io"><div class="mobile-logo"></div></a>
   </div>
   <div class="collapse navbar-collapse" id="frankly-navbar-collapse">
      <!--Nav Bar List Goes Here-->
   </div>
</nav>

<script>
	jQuery(document).ready(function($){
		load_menus();
	});
</script>

<div class="sidebar-container">

	<div class="sidebar-logo"><a href="http://franklyinc.github.io"></a></div>

	<div class="sidebar-content sidebar-search">

		<form action="search.html">
			<input type="text" class="form-control" name="q" placeholder="Search Frankly docs" aria-describedby="basic-addon2">
		</form>
  
	</div>


	<div class="sidebar-content" id="side-nav-container">
		<!--Side Bar List Goes Here-->
	</div>

</div>


<div class="container container-body">
	<div class="header">
		<h1 class="noborder">
			Advanced Integrations
		</h1>	
	
<br>

			<ul>
				<li><a href="#Open_Room">Directly Opening a Room</a>
				<li><a href="#Server_APIs">Server API Access</a>
				<li><a href="#Installing_ServerSDKs">Server SDKs</a></li>
				<li><a href="#In-depth_Usage">In-depth Usage</a>
       			    <ul>
				        <li><a href="#Authentication">Authentication</a></li>
				        <li><a href="#Rooms">Rooms</a></li>
				        <li><a href="#Messages">Messages</a></li>
				        <li><a href="#Announcements">Announcements</a></li>
				        <li><a href="#Users">Users</a></li>
				        <li><a href="#Files">Files</a></li>
				        <li><a href="#Moderation">Moderation</a></li>
			        </ul>
				<li><a href="#JS_SDK_Meteor">Using the JS SDK with Meteor</a></li>
			</ul>

	</div>

<br>
<br>

	<div class="doc">
		<div class="section" id="Open_Room">
			<h3>
				Opening a Room without a Room List
			</h3>
	
			<p>
				While the Frankly client SDKs do provide UI for the Frankly Room List and Frankly Rooms, we understand that displaying a Frankly Room List won't always make sense in the context of many developers' applications. For that reason, we're providing a client API meant for directly accessing any Room, already created for your application, simply by passing a Room ID. Please note of course that you have the option of simply hardcoding the Room ID in your client or using our server API to fetch the desired Room ID.
			</p>
		</div>
	

		<div class="section" id="Open_Room_iOS">
			<h4>
				Using the Room API in the iOS SDK
			</h4>
	
			<p>
				In order to open a Frankly Room in the SDK while bypassing the Frankly Room List UI you must specify the <code>roomId</code> for the Room you'd like to open, as well as the Room <code>title</code> that you'd like to show to the end user while the Frankly SDK is retrieving the Room's metadata from Frankly servers. Calling the following will retrieve a view controller for the given <code>roomId</code> if non-nil, otherwise it will return nil.
			</p>
		

<pre class="prettyprint"><code class="lang-ruby">
- (UIViewController *)roomViewControllerWithRoomId:(NSNumber *)roomId title:(NSString *)title;
</code></pre>


<br>

			<p>
				Calling the following will retrieve a Frankly-styled navigation controller which contains a view controller for the given <code>roomId</code> if non-nil, otherwise it will return nil.
			</p>


<pre class="prettyprint"><code class="lang-ruby">
- (UIViewController *)roomNavigationControllerWithRoomId:(NSNumber *)roomId title:(NSString *)title;
</code></pre>

		</div>


		<div class="section" id"Open_Room_Android">
			<h4>
				Using the Room API in the Android SDK
			</h4>
	
			<p>
				<code>RoomActivity</code> allows the user to join a specified chatroom directly.
			</p>


<pre class="prettyprint"><code class="lang-java">
Intent intent = new Intent(this, RoomActivity.class);

intent.putExtra(RoomActivity.EXTRA_ROOM_ID, roomId);

context.startActivity(intent);
</code></pre>	
		
		</div>


		<div class="section" id="Server_APIs">
			<h3>
				Server API Access
			</h3>
	
			<p>
				The sections below describes how developers are able to interact direction with Frankly's server APIs to create more custom integrations on the Frankly Chat Platform. To provide a clean interface for develoeprs to interact with Frankly's server APIs, we're providing a Python module and Ruby gem that are meant to easily be integrated with your existing backend stack. In the event that you need access to Frankly's server APIs in a language that is better compatible with your backend or that you are more comfortable with, please let us know by sending an email to <a href="mailto:platform-support@franklychat.com">platform-support@franklychat.com</a>.
			</p>

		</div>


		<div class="section" id="Installing_ServerSDKs">
			<h3>
				Installing the Server SDKs
			</h3>
		</div>


		<div class="section" id"Installing_Python_SDK">
			<h4>
				Installing the Python SDK
			</h4>

			<p>	
				The Frankly Python module can be installed, like most Python modules, using pip:
			</p>	


<pre class="prettyprint"><code>
$ pip install frankly-python
</code></pre>

<br>

			<h5>
				<b>Compatibility</b>
			</h5>
		
			<p>
				The frankly-python module requires Python 2.7.9+ or Python 3.4.0+ to be used successfully.
			</p>
		
			
<br>
			
			
			<h5>
				<b>Testing</b>
			</h5>
			
			<p>
				The test suite relies on environment variables to figure out where to connect to for tests that make API calls. You should set these three environment variables before running the tests:
			</p>

			
<pre class="prettyprint"><code class="lang-py">
export FRANKLY_APP_HOST=https://app.franklychat.com
export FRANKLY_APP_KEY={app key from the Frankly Console}
export FRANKLY_APP_SECRET={app secret from the Frankly Console}
</code></pre>


<br>


			<p>
				The easiest way to run the test suite is to use the nose python module, then run:
			</p>

<pre class="prettyprint"><code>
$ python2 -m nose
</code></pre>


<br>


<pre class="prettyprint"><code>
$ python3 -m nose
</code></pre>


<br>

		</div>


		<div class="section" id="Installing_Ruby_SDK">
			<h4>
				Installing the Ruby SDK
			</h4>
		
			<p>
				In your Gemfile include:
			</p>
		
<pre class="prettyprint"><code class="lang-rb">
gem 'frankly-ruby', :git => 'git://github.com/franklyinc/frankly-ruby.git'
</code></pre>


<br>


			<p>
				... then run:
			</p>
		
<pre class="prettyprint"><code>
$ bundle install
</code></pre>


<br>


			<p>
				To use the Frankly Ruby gem:
			</p>
		
<pre class="prettyprint"><code>
require 'frankly-ruby'
</code></pre>

		</div>


		<div class="section" id="In-depth_Usage">
			<h3>
				In-depth Usage
			</h3>

			<p>
				The sections below explain how to use the module to authenticate and query the <b>Frankly API</b> using other SDKs that can be embedded other types of applications (servers, automation workers, desktop applications, etc...).
			</p>

<br>

			<p>
			  <em>We'll be using Ruby for code examples, please consult the API reference for the language you're interested in to get more details of language-specific syntaxes.</em>
			</p>

<br>

			<p>
				All operations to the API are made from instances of the <b>FranklyClient</b> class. Those objects expose methods to the application which map to remote procedure calls (RPC) on the <b>Frankly</b> servers, they also negotiate and maintain the state required by the API's security policies.
			</p>

			<p>
				Here's how <b>FranklyClient</b> instances are created:
			</p>


<pre class="prettyprint"><code class="lang-ruby">
	require 'frankly-ruby'
	client = FranklyClient.new
 </code></pre>

		</div>

		
		<div class="section" id="Authentication">
			<h4>
				Authentication
			</h4>


			<p>
				Before performing any operation (calling any method) the client instance needs to authenticate against Frankly API. The API supports different permission levels but this module is designed to only allow <em>admin</em> authentication.
			</p>

			<p>
				In order to authenticate as an <em>admin</em> user, the client needs to be given the <code>app_key</code> and <code>app_secret</code> values obtained from the <a href="https://console.franklychat.com/">Frankly Admin Console</a>.
			</p>

			<p>
				Here's how to perform authentication:
			</p>

<pre class="prettyprint"><code class="lang-ruby">
	require 'frankly-ruby'

	app_key    = 'app_key from Frankly Console'
	app_secret = 'app_secret from Frankly Console'

	client = FranklyClient.new
	client.open(app_key, app_secret)
</code></pre>

<br>

			<p>
				The call to <b>open</b> returns a session object if the authentication was successful. The application can now use this instance of <b>FranklyClient</b> to perform other operations.
			</p>

			<p>
				<em>Please do not publish your</em> <b>app_secret</b> <em>value to the public. This can have security implications and could be used by an attacker to alter the content of your application.</em>
			</p>

		</div>


		<div class="section" id="Rooms">
			<h4>
				Rooms
			</h4>


			<p>
				One of the central concepts in the <b>Frankly API</b> is the chat room. A chat room is a collection of messageswith some associated meta-data, like the title, description, or avatar image, that can be displayed when the end users access a mobile or web app that uses the <b>Frankly SDK</b>. With the <b>Frankly API</b>, you can create, update, and delete chat rooms.
			</p>

			<p>
				This code snippet shows how to create chat rooms:
			</p>

<pre class="prettyprint"><code class="lang-ruby">
	require 'frankly-ruby'

	room_payload = {
		title:       'Hi',
		description: 'My First Chat Room',
		status:      'active'
	}
	room = client.create_room(room_payload)
</code></pre>

<br>

			<p>
				As we can see here, when creating the room the application must specify a <em>status</em> property which can be one of the following:
			</p>

			<ul>
				<li><b>unpublished</b> In this state, the room will not be shown to clients fetching the list of available rooms in the app. This is useful if the application needs to create rooms that shouldn't be available yet because they still need to be modified.</li>
				<li><b>active</b> In this state, the room will be fetched by clients and will be displayed in the list of available Rooms that end users can join to start chatting with each other.</li>
				<li><b>inactive</b> This last state is an intermediary state between the first two. The room will be part of fetching operations but it will not be displayed in the mobile or web app UI. This state is useful for testing purposes.</li>
			</ul>

<br>

			<p>
				In addition to the data available in the room object, you can also fetch data about the number of users that are in that room. The room count function returns a hash that lists the <b>active</b>, <b>online</b>, and <b>subscribed</b> user counts. <b>Online</b> represents the users that are currently in the room, <b>subscribed</b> represents the users that have subscribed to the room, and <b>active</b> is the union of the online and subscribed users.
			</p>

<br>

			<p>
				This code snippet shows how to fetch the room count:
			</p>

 
<pre class="prettyprint"><code class="lang-ruby">
	room = client.create_room(room_payload)
	count = client.read_room_count(room['id'])
</code></pre>

		</div>


		<div class="section" id="Messages">
			<h4>
				Messages
			</h4>

			<p>
				Frankly, being a chat platform, allows applications to send and receive messages. Naturally, <b>FranklyClient</b> instances can fetch messages and publish them to chat rooms.
			</p>

			<p>
				This code snippet shows how to create messages:
			</p>

<pre class="prettyprint"><code class="lang-ruby">
	require 'frankly-ruby'

	message1_payload = {
		contents: [{
		type:  'text/plain',
        value: 'Hello World!'
	}]
	}
	message1 = client.create_room_message(room['id'],create_payload)

	message2_payload = {
		contents: [{
         type: 'image/*',
         url:  'https://app.franklychat.com/files/...'
	 	}]
     }
	 message2 = client.create_room_message(room['id'],create_payload)
</code></pre>

<br>

			<p>
				Let's explain what's happening here: messages published to chat rooms can contain multiple parts; they could contain a few text enries, text an an image, several images, etc. The contents property of the message is actually a list of objects, the fields of the <em>contents</em> objects are:
			</p>

			<ul>
				<li><b>type</b> This is the mime type of the actual content it represents, it gives the application information about how to render the content. This field is mandatory.</li>
				<li><b>value</b> This is used for inline resources directly embedded into the message. One of <em>value</em> or <em>url</em> must be specified.</li>
				<li><b>url</b> This is the inline resource that is directly imbedded into the message. One of <em>value</em> or <em>url</em> must be specified.</li>
			</ul>

			<p>
				Typically, text messages are inlined because they are small enough resources that they can be embedded into the message without having an impact on the user experience. Images, on the other hand, may take a while to download and caching mechanisms can be used to optimize rendering by preventing large resources from downloading too often. This is why we provide the <em>value</em> as a remote resouce (we'll see later in the <em>Files</em> section how to generate remote resource URLs).
			</p>

			<p>
				<em>Keep in mind that when a message is created, it will be broadcasted to every client application that is currently listening for messages in that chat room.</em>
			</p>

		</div>
		

		<div class="section" id="Announcements">
			<h4>
				Announcements
			</h4>

			<p>
				Announcements are a type of message that is only available to admin users. A client authenticated with admin priviledges can create announcements in the app which can be published to one or more rooms at a later time.
			</p>

			<p>
				Currently, the only type of Announcement is the Sticky Message. Once the most recent Sticky Message sent reaches the top of the Chat Room UI, it will anchor to the top until a new Sticky Message replaces it. This provides context to the end users about what has recently happened or what is currently happening to make it easier for them to jump in and chat.
			</p>

			<p>
				Here's how an app using the frankly module would create and then publish announcements:
			</p>

 
<pre class="prettyprint"><code class="lang-ruby">
	require 'frankly-ruby'

	anno_payload = {
		sticky: true,
		contents: [{
			type:  'text/plain',
			value: 'Hello World!'
		}]
	}

	anno = client.create_announcement(anno_payload)
	client.create_room_message(room.id, {announcement: anno['id']})
</code></pre>

<br>

			<p>
				As we can see here, the announcement is created with the same structure than a regular message. The content of the announcement well be set as the message content when it is published to the room and the contents field obeys the rules about inline and remote content that were described in the <i>Messages</i> section.
			</p>

		</div>
		

		<div class="section" id="Users">
			<h4>
				Users
			</h4>

			<p>
				A central concept of the <b>Frankly API</b> is the <i>User</i>. Users represent people using the chat platform within an app. They are created during authentication and one using in the <b>Frankly API</b> should be to a one user on the host application.
			</p>

		</div>

		<div class="section" id="Roles">
			<h5>
				<b>Roles</b>
			</h5>

			<p>
				Users may be granted different roles which allows or denies them access to certain operations. The Frankly API currently defines four roles that can be assigned to users:
			</p> 

			<ol>
				<li><b>Admin</b>
					<p>
						Admin users have the highest level of permissions, they can perform all available operations on the Frankly API. Each application is given one default admin user when created. To authenticate as the default admin user a client must set the Role parameter to 'admin' and the Partner User ID to null when generating the identity token. This is usually only done when using the Frankly API from your own backend as giving such power to a mobile or web client may expose your application to security issues. Among the extra operations that admin users can perform are managing other users' accounts, banning and unbanning specific users, etc...
					</p>
				</li>
   
				<li><b>Regular</b>
					<p>
						This is the default role for users that have been authenticated with a Partner User ID when generating an identity token. Regular users can perform all operations required to take full advantage of the Frankly features, like creating new chat rooms, sending and receiving messages, modifying their Display Name and Profile Avatar, etc... Unlike Admin Users, regular users cannot affect other users' accounts, they only operate on their own data.
					</p>
				</li>
   
				<li><b>Guest</b>
					<p>
						Guest Users can be used to remove barriers in product adoption. They have access to basic operations which let them experience chat without requiring a fully authenticated account. Guest Users can be converted to regular users later on if needed.
					</p>
				</li>
   
				<li><b>Anonymous</b>
					<p>
						This is the role offering the least amount of permissions to a user as it doesn't require any form of authentication (the Partner User ID can be set to null when generating the identity token) but is only allowed to perform read operations. Anonymous Users can view chat Rooms and messages sent by others but cannot send messages themselves, edit their Display Name or Profile Avatar either, etc... Anonymous Users can be seen simply as observers, providing an overview of the product experience before creating an account or logging in.
					</p>
				</li>
			</ol>
		</div>
  
  
		<div class="section" id="Files">
			<h4>
				Files
			</h4>

			<p>
				Objects of the <b>Frankly API</b> can have URL properties set to reference remote resources like images. All these URLs must be within the <b>+https://app.franklychat.com+</b> domain, which means an application must upload these resources to Frankly servers.
			</p>

			<p>
				Uploading a file happens in two steps, first the application needs to request a new file URL to the <b>Frankly API</b>, then it can use that URL to upload a resource to Frankly servers. Lukily the frankly module abstracts this nicely in a single operation, here's an example of how to set an image for a chat room:
			</p>

 
<pre class="prettyprint"><code class="lang-ruby">
    require 'frankly-ruby'

    file_payload = {
      category:  'useravatar',
      type: 'image'
    }

    file = client.upload_file_from_path('./path/to/image.pnp',file_payload)
    room = client.update_room(room.id, {avatar_image_url = file['url']})
</code></pre>

<br>

			<p>
				The object returned by a call to <b>upload_file_from_path</b> and other upload methods is created in the first step described above. The <b>category</b> parameter shown here is used by the <b>Frankly API</b> to determine which formatting rules should be applied to the resource. Since the files will be optimized for different situations based on their category, it will be easier to integrate with Frankly and this will create a better user experience.
			</p>

			<p>
				Here are the file categories currently available:
			</p>

			<ul>
				 <li><b>chat</b>
				   This is the default category and is usually applied to images sent by end users.</li>
				 <li><b>useravatar</b>
				   This category is for files that will be displayed in room lists.</li>
				 <li><b>roomavatar</b>
				   This category is for files that will be displayed in room lists.</li>
				 <li><b>featuredavatar</b>
				   This category is for files that will represent featured rooms.</li>
				 <li><b>sticker</b>
				   This category is for files that are used in sticker messages.</li>
				 <li><b>stickerpack</b>
				   This category is for files that will be the avatar of a sticker pack.</li>
			</ul>
		</div>
	

		<div class="section" id="Moderation">
			<h4>
				Moderation
			</h4>
		</div>


		<div class="section" id="Bans">
			<h5>
				<b>Bans</b>
			</h5>
 
			<p>
				With the <b>Frankly API</b>, you can read the ban status of a given user. A banned user will not be able to send messages so it will be useful to determine programmatically if a user has been banned. Here's an example of how you can read the ban status of a user:
			</p>

<pre class="prettyprint"><code>
require ‘frankly-client’

user_id = some number
ban = client.read_user_ban(user_id)
</code></pre>

		</div>
		
		
		<div class="section" id="JS_SDK_Meteor">
			<h3>
				Using the JavaScript SDK with Meteor
			</h3>
			
			<p>
				For backend frameworks that simulate synchronicity, such as <a href="https://www.meteor.com/">Meteor</a> which simulates synchronicity using Fibers, you will need to put a 
				wrapper around the asynchronous calls made within the Frankly JavaScript SDK. The Frankly JavaScript SDK makes use of the Promise design 
				pattern, putting asynchronous callbacks in the <code>.then()</code> and <code>.catch()</code> functions of a call.
			</p>
			
			<p>
				In order to make asynchronous callbacks within a Meteor environment, you must run the code within a Fiber. This can be achieved by 
				utilising the <code>Meteor.bindEnvironment</code> call, and passing the argument returned by the initial call.
			</p>

			<div class="panel panel-default note">
			  <div class="panel-body">
			    <b>Note</b> This is only applicable for using the Frankly JavaScript SDK on the server, it is not necessary for running the SDK on the client.
			  </div>
			</div>
			
			<p>
				Both traditional callbacks and Promise callbacks will need to be wrapped in order for Meteor process the code. See the example below:
			</p>

			
<pre class="prettyprint"><code class="lang-js">
client = new FranklySdk.Client(Meteor.settings.FranklyServerProtocol);
client.open(app.authKey, app.authSecret);

client.on('connect', <strong>Meteor.bindEnvironment</strong>(function() {
    client.readRoomList()
        .then(<strong>Meteor.bindEnvironment</strong>(function(roomList) {  
            // Example code
        }))
        .catch(<strong>Meteor.bindEnvironment</strong>(function(error) {
            client.close();
            console.log("An error occurred: ", error);
        }));
}));
</code></pre>


<br>		


		</div>


<br>
<br>
<br>
<br>

	<div class="pager-container">
		<nav>
		  <ul class="pager">
		    <li class="previous"><a href="BasicIntegration.html"><span aria-hidden="true">&larr;</span> Basic Integration</a></li>
		    <li class="next"><a href="APIReference.html">API Reference <span aria-hidden="true">&rarr;</span></a></li>
		  </ul>
		</nav>
	</div>

</div>

<br>
<br>


</html>
